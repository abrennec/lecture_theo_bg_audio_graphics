/* autogenerated by Processing revision 1277 on 2022-01-19 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Algol extends PApplet {

PGraphics pg;
PShader portalShader;

Boolean trigger = true;

final int depthSteps = 12;
final int distance = 200;
final float goldenRatio = 1.618033988749f;
int currentFill;
int jitterFactor = 0;

float xWavelength = 62.0f;
float yWavelength = 37.0f;
float zWavelength = 150.0f;

float xAmplitude = 50.0f;
float yAmplitude = 30.0f;
float zAmplitude = 2;

float phase = 0.0f;
float zoff = 0.0f;
float r;
float velocity = 1.0f;

 public void preload()
{
  
}

 public void setup() 
{
    portalShader = loadShader("portalfrag.glsl", "portalvert.glsl");
      
    //fullScreen(P3D);
    /* size commented out by preprocessor */;
    /* smooth commented out by preprocessor */;
    
    float fov = PI/3.0f;

perspective(fov, PApplet.parseFloat(width)/PApplet.parseFloat(height), 
            0.1f, 20000);
    
    currentFill = 15;
}

 public void mouseReleased() 
{
    jitterFactor = 30;
}

 public void draw() 
{   
    directionalLight(255, 255, 255, 0, -1, -1);
    ambientLight(102, 102, 102);
    background(245);
    translate(width / 2, 0, -50);
    stroke(currentFill);
    fill(currentFill);
    float zfactor = map(sin(frameCount / zWavelength), -1.0f, 1.0f, 1.25f, 1.25f + zAmplitude);

    
    for (int i = 0; i <= depthSteps; i++)
    {
        float xOffset = xAmplitude * sin((frameCount / xWavelength) + 0.8f * i);
        float yOffset = yAmplitude * map(sin((frameCount / yWavelength) + 0.8f * i), -1.0f, 1.0f, -1.0f, 0.0f);
        float edgeLength = (distance / 4);
        float pyramidX = (width / 2.0f) + xOffset;
        float pyramidZ = i * - distance * zfactor;
        float quadY = height / 2 * goldenRatio + yOffset;
        
        pushMatrix();
        
        translate(0, 0, pyramidZ);

        drawPyramid(edgeLength, -pyramidX + getJitter(jitterFactor), yOffset + getJitter(jitterFactor), getJitter(jitterFactor));
        drawPyramid(edgeLength, pyramidX + getJitter(jitterFactor), yOffset + getJitter(jitterFactor), getJitter(jitterFactor)); 
        drawQuad(200, distance * (zfactor / 4), xOffset + getJitter(jitterFactor), quadY + getJitter(jitterFactor), getJitter(jitterFactor));   
        
        popMatrix();
    }   

    if(jitterFactor > 0) jitterFactor--;
    
    drawSecondScene();
    
    stroke(255,0,0);
    strokeWeight(0.5f);
    noFill();
    phase += 0.01f;
    
    
    r = 300;
    
    
    
   // shader(portalShader);
    pushMatrix();
    translate(0, height/2, 0);
    
    beginShape();
    for (float a = 0.0f; a < TWO_PI; a += 0.02f) {
    // let xoff = map(cos(a),-1,1,0,mouseX/100);
    // let yoff = map(sin(a),-1,1,0,mouseX/100);
    // let xoff = map(cos(a),-1,1,0,2);
    // let yoff = map(sin(a+phase),-1,1,0,2);
      float xoff = map(cos(a), -1.0f, 1.0f, 0.0f, 2.0f);
      float yoff = map(sin(a), -1.0f, 1.0f, 0.0f, 2.0f);
      //r = map(noise(xoff, yoff,zoff), 0.0, 1.0, 100.0, 250.0) * ((float) frameCount)/velocity;
      r = map(noise(xoff, yoff,zoff), 0.0f, 1.0f, 100.0f, 250.0f) * map(sin(frameCount/ 100.0f), -1.0f, 1.0f, 1.0f, 2.0f);
      float x = r * cos(a);
      float y = r * sin(a);
      vertex(x, y);
    }
    endShape(CLOSE);
    
    popMatrix();
    
    zoff += 0.01f;
    
}


 public void drawPyramid(float t, float posX, float posY, float posZ) 
{ 
    
    stroke(0);
    
    //this pyramid has 4 sides, each drawn as a separate triangle
    //each side has 3 vertices, making up a triangle shape
    //the parameter " t " determines the squareWidth of the pyramid
    beginShape(TRIANGLES);
    
    vertex( -t + posX, -t + posY, -t + posZ);
    vertex(t + posX, -t + posY, -t + posZ);
    vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    vertex(t + posX, -t + posY, -t + posZ);
    vertex(t + posX, -t + posY, t + posZ);
    vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    vertex(t + posX, -t + posY, t + posZ);
    vertex( -t + posX, -t + posY, t + posZ);
    vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    vertex( -t + posX, -t + posY, t + posZ);
    vertex( -t + posX, -t + posY, -t + posZ);
    vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    endShape();
}

 public void drawQuad(float squareWidth, float squareDepth, float posX, float posY, float posZ)
{
    beginShape(QUAD);
    
    fill(currentFill);
    
    vertex(-squareWidth + posX, posY, posZ);
    vertex(posX, posY,  -squareDepth + posZ);
    vertex(squareWidth + posX, posY, posZ);
    vertex(posX, posY, squareDepth + posZ);
    
    endShape();
}


 public float getJitter(int factor)
{
    return (factor / 5) * random(-1.0f, 1.0f);
}

 public void drawSecondScene()
{
  pg = createGraphics(width, height, P3D);
  pg.beginDraw();
  {
    //directionalLight(255, 255, 255, 0, -1, -1);
  //ambientLight(102, 102, 102);
  pg.background(255);
  pg.translate(width / 2, 0, -50);
  pg.stroke(255,0,0);
  pg.fill(255,0,0);
  
  float zfactor = map(sin(frameCount / zWavelength), -1.0f, 1.0f, 1.25f, 1.25f + zAmplitude);

    
  for (int i = 0; i <= depthSteps; i++)
  {
      float xOffset = xAmplitude * sin((frameCount / xWavelength) + 0.8f * i);
      float yOffset = yAmplitude * map(sin((frameCount / yWavelength) + 0.8f * i), -1.0f, 1.0f, -1.0f, 0.0f);
      float edgeLength = (distance / 4);
      float pyramidX = (width / 2.0f) + xOffset;
      float pyramidZ = i * - distance * zfactor;
      float quadY = height / 2 * goldenRatio + yOffset;
        
      pushMatrix();
        
      translate(0, 0, pyramidZ);

      drawSecondPyramid(edgeLength, -pyramidX + getJitter(jitterFactor), yOffset + getJitter(jitterFactor), getJitter(jitterFactor));
      drawSecondPyramid(edgeLength, pyramidX + getJitter(jitterFactor), yOffset + getJitter(jitterFactor), getJitter(jitterFactor)); 
      drawSecondQuad(200, distance * (zfactor / 4), xOffset + getJitter(jitterFactor), quadY + getJitter(jitterFactor), getJitter(jitterFactor));   
        
     popMatrix();
     
  }
  
  }
      pg.endDraw();
  
  
  if(frameCount >= 10 && trigger)
  {
    pg.save("secondscene.png");
    trigger = false;
  }
  
  shader(portalShader);
  portalShader.set("tex", pg);
}

 public void drawSecondPyramid(float t, float posX, float posY, float posZ) 
{ 
    
    pg.stroke(255,0,0);
    
    //this pyramid has 4 sides, each drawn as a separate triangle
    //each side has 3 vertices, making up a triangle shape
    //the parameter " t " determines the squareWidth of the pyramid
    pg.beginShape(TRIANGLES);
    
    pg.vertex( -t + posX, -t + posY, -t + posZ);
    pg.vertex(t + posX, -t + posY, -t + posZ);
    pg.vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    pg.vertex(t + posX, -t + posY, -t + posZ);
    pg.vertex(t + posX, -t + posY, t + posZ);
    pg.vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    pg.vertex(t + posX, -t + posY, t + posZ);
    pg.vertex( -t + posX, -t + posY, t + posZ);
    pg.vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    pg.vertex( -t + posX, -t + posY, t + posZ);
    pg.vertex( -t + posX, -t + posY, -t + posZ);
    pg.vertex(posX, height / 2 * goldenRatio + posY, posZ);
    
    pg.endShape();
}

 public void drawSecondQuad(float squareWidth, float squareDepth, float posX, float posY, float posZ)
{
    pg.beginShape(QUAD);
    
    pg.fill(255,0,0);
    
    pg.vertex(-squareWidth + posX, posY, posZ);
    pg.vertex(posX, posY,  -squareDepth + posZ);
    pg.vertex(squareWidth + posX, posY, posZ);
    pg.vertex(posX, posY, squareDepth + posZ);
    
    pg.endShape();
}


  public void settings() { size(1000, 700, P3D);
smooth(8); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Algol" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
